# Java中的阻塞队列

## 什么是阻塞队列

- 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。
- 这两个附加的操作支持阻塞的插入和移除方法。
  1. 支持阻塞的插入方法：
     - 意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。
  2. 支持阻塞的移除方法：
     - 意思是在队列为空时，获取元素的线程会等待队列变为非空。
- 阻塞队列常用于生产者和消费者的场景：
  - 生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。
  - 阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。
- 在阻塞队列不可用时，这两个附加操作提供了4种处理方式，如下表所示。

![](img/42.png)

- 抛出异常：
  - 当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（"Queue full"）异常。
  - 当队列空时，从队列里获取元素会抛出NoSuchElementException异常。
- 返回特殊值：
  - 当往队列插入元素时，会返回元素是否插入成功，成功返回true。
  - 如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。
- 一直阻塞：
  - 当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。
  - 当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。
- 超时退出：
  - 当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。

---

## Java里的阻塞队列

- JDK 7提供了7个阻塞队列，如下。
  - ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。
  - LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。
  - PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。
  - DelayQueue：一个使用优先级队列实现的无界阻塞队列。
  - SynchronousQueue：一个不存储元素的阻塞队列。
  - LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
  - LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

### ArrayBlockingQueue

- ArrayBlockingQueue是一个用数组实现的有界阻塞队列。

- 此队列按照先进先出（FIFO）的原则对元素进行排序。

- 默认情况下不保证线程公平的访问队列。

  - 所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。
  - 非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。
  - 为了保证公平性，通常会降低吞吐量。

- 我们可以使用以下代码创建一个公平的阻塞队列。

  `ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);`

- 访问者的公平性是使用可重入锁实现的，代码如下。

  ```Java
  public ArrayBlockingQueue(int capacity, boolean fair) {
      if (capacity <= 0)
          throw new IllegalArgumentException();
      this.items = new Object[capacity];
      lock = new ReentrantLock(fair);
      notEmpty = lock.newCondition();
      notFull =  lock.newCondition();
  }
  ```

### LinkedBlockingQueue

- LinkedBlockingQueue是一个用链表实现的有界阻塞队列。
- 此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。

### PriorityBlockingQueue

- PriorityBlockingQueue是一个支持优先级的无界阻塞队列。
- 默认情况下元素采取自然顺序升序排列。
- 也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。
- 需要注意的是不能保证同优先级元素的顺序。

### DelayQueue

- DelayQueue是一个支持延时获取元素的无界阻塞队列。
  - 队列使用PriorityQueue来实现。
  - 队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。
  - 只有在延迟期满时才能从队列中提取元素。
- DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。
  1. 缓存系统的设计：
     - 可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。
  2. 定时任务调度：
     - 使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。

### SynchronousQueue

- SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。
- 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。
- SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。
- SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。

### LinkedTransferQueue

- LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。
- 相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。

##### transfer方法

- 如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。
- 如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。

##### tryTransfer方法

- tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。
- 和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。
- 对于带有时间限制的tryTransfer(E e，long timeout，TimeUnit unit)方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。

### LinkedBlockingDeque

- LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。
  - 所谓双向队列指的是可以从队列的两端插入和移出元素。
  - 双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。
  - 相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。
  - 以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。
  - 另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。
  - 但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。
- 在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。